{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Command-Line Parsing Library (<code>cmdlp</code>)","text":""},{"location":"#overview","title":"Overview","text":"<p><code>cmdlp</code> is a lightweight, easy-to-use C++ library for parsing command-line options. It simplifies the process of handling various types of options, including toggle switches, value-based options, and multi-value options, while providing a clean and extensible interface.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Support for short (<code>-o</code>) and long (<code>--option</code>) options.</li> <li>Toggle options (e.g., <code>--verbose</code> for enabling verbose output).</li> <li>Value-based options (e.g., <code>--file input.txt</code>).</li> <li>Multi-value options (e.g., <code>--mode auto</code> where mode can be <code>auto|manual|test</code>).</li> <li>Positional options (e.g. <code>./program --verbose a.txt b.txt</code>, where <code>a.txt</code> and <code>b.txt</code> are the two positional options).</li> <li>Positional lists (e.g. <code>./program a.txt b.txt c.txt</code>, where the values are returned as a <code>std::vector&lt;std::string&gt;</code>).</li> <li>Grouping and labeling options via separators.</li> <li>Automatically generated usage message.</li> <li>Automatically generated help messages.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Include the entire <code>cmdlp</code> which you can find in <code>include</code>.</p> <p>Then, include the necessary headers in your project:</p> <pre><code>#include \"cmdlp/parser.hpp\"\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#defining-and-parsing-command-line-options","title":"Defining and Parsing Command-Line Options","text":"<p>Here is an example of how to define and parse command-line options using <code>cmdlp</code>:</p> <pre><code>#include &lt;iostream&gt;\n#include \"cmdlp/parser.hpp\"\n\nint main(int argc, char *argv[]) {\n    cmdlp::Parser parser(argc, argv);\n\n    // Define options\n    parser.addOption(\"-db\", \"--double\", \"Double value\", false, 0.2);\n    parser.addOption(\"-i\", \"--int\", \"An integer value\", false, -1);\n    parser.addToggle(\"-h\", \"--help\", \"Shows help for the program.\", false);\n\n    // Parse options\n    parser.parseOptions();\n\n    // Retrieve and display parsed options\n    std::cout &lt;&lt; \"Double value  : \" &lt;&lt; parser.getOption&lt;double&gt;(\"--double\") &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Integer value : \" &lt;&lt; parser.getOption&lt;int&gt;(\"--int\") &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Help          : \" &lt;&lt; parser.getOption&lt;bool&gt;(\"--help\") &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre> <p>Running the above program with the following options:</p> <pre><code>./example --double 3.14 --int 42 --help\n</code></pre> <p>Produces:</p> <pre><code>Double value  : 3.14\nInteger value : 42\nHelp          : 1\n</code></pre>"},{"location":"#defining-and-parsing-positional-arguments","title":"Defining and Parsing Positional Arguments","text":"<p>Positional options are unflagged inputs identified by their position in the command-line input. Here is an example demonstrating how to define and parse positional options:</p> <pre><code>#include &lt;iostream&gt;\n#include \"cmdlp/parser.hpp\"\n\nint main(int argc, char *argv[]) {\n    cmdlp::Parser parser(argc, argv);\n\n    // Required positional option.\n    parser.addPositionalOption(\"-in\", \"--input\", \"Input file.\", true);\n    // Optional positional option.\n    parser.addPositionalOption(\"-out\", \"--output\", \"Output file.\", false);\n\n    // Parse options.\n    parser.parseOptions();\n\n    // Retrieve and display positional options.\n    std::cout &lt;&lt; \" Input  (-in)  : \" &lt;&lt; parser.getOption&lt;std::string&gt;(\"--input\") &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \" Output (-out) : \" &lt;&lt; parser.getOption&lt;std::string&gt;(\"--output\") &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre> <p>So if you provide.</p> <pre><code>\\$ ./example in.txt\n</code></pre> <p>Produces:</p> <pre><code> Input  (-i) : in.txt\n Output (-o) : \n</code></pre>"},{"location":"#defining-and-parsing-a-positional-list","title":"Defining and Parsing a Positional List","text":"<p>Positional lists are unflagged inputs placed at the end of the command-line input. Here is an example demonstrating how to define and parse positional lists:</p> <pre><code>#include &lt;iostream&gt;\n#include \"cmdlp/parser.hpp\"\n\nint main(int argc, char *argv[]) {\n    cmdlp::Parser parser(argc, argv);\n\n    // Positional options.\n    parser.addPositionalOption(\"-i\", \"--input\", \"Input file.\", true);\n    parser.addPositionalOption(\"-o\", \"--output\", \"Output file.\", true);\n    // Positional list.\n    parser.addPositionalList(\"-f\", \"--files\", \"List of extra files.\", false);\n\n    // Parse options.\n    parser.parseOptions();\n\n    // Retrieve and display positional options.\n    std::cout &lt;&lt; \" Input  (-i) : \" &lt;&lt; parser.getOption&lt;std::string&gt;(\"--input\") &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \" Output (-o) : \" &lt;&lt; parser.getOption&lt;std::string&gt;(\"--output\") &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \" Extra  (-f) : \";\n    for (const auto &amp;file : parser.getOption&lt;cmdlp::Values&gt;(\"--files\")) {\n        std::cout &lt;&lt; file &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre> <p>So if you provide.</p> <pre><code>\\$ ./example in.txt out.txt a.txt b.txt c.txt\n</code></pre> <p>Produces:</p> <pre><code> Input  (-i) : in.txt\n Output (-o) : out.txt\n Extra  (-f) : a.txt b.txt c.txt\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>Here is a more comprehensive example demonstrating various features of <code>cmdlp</code>:</p> <pre><code>#include &lt;iostream&gt;\n#include \"cmdlp/parser.hpp\"\n\nint main(int argc, char *argv[]) {\n    cmdlp::Parser parser(argc, argv);\n\n    parser.addSeparator(\"General Options:\");\n    parser.addOption(\"-db\", \"--double\", \"Double value\", 0.5, false);\n    parser.addOption(\"-i\", \"--int\", \"Integer value\", -1, false);\n\n    parser.addSeparator(\"Toggle Options:\");\n    parser.addToggle(\"-v\", \"--verbose\", \"Enable verbose mode\", false);\n\n    parser.addSeparator(\"Multi-value Options:\");\n    parser.addMultiOption(\"-m\", \"--mode\", \"Operation mode\", {\"auto\", \"manual\"}, \"auto\");\n\n    parser.parseOptions();\n\n    std::cout &lt;&lt; \"Help: \\n\" &lt;&lt; parser.getHelp() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Parsed Options: \\n\";\n    std::cout &lt;&lt; \"  Double: \" &lt;&lt; parser.getOption&lt;double&gt;(\"--double\") &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"  Integer: \" &lt;&lt; parser.getOption&lt;int&gt;(\"--int\") &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"  Verbose: \" &lt;&lt; parser.getOption&lt;bool&gt;(\"--verbose\") &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"  Mode: \" &lt;&lt; parser.getOption&lt;std::string&gt;(\"--mode\") &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre> <p>Running with:</p> <pre><code>./example --double 3.14 --int 42 --verbose --mode manual\n</code></pre> <p>Produces:</p> <pre><code>Help: \n\nGeneral Options:\n[-db] --double  (   0.5) : Double value\n[-i ] --int     (    -1) : Integer value\n\nToggle Options:\n[-v ] --verbose ( false) : Enable verbose mode\n\nMulti-value Options:\n[-m ] --mode    (  auto) : Operation mode [auto, manual]\n\nParsed Options: \n  Double: 0.5\n  Integer: -1\n  Verbose: 0\n  Mode: auto\n</code></pre>"},{"location":"#api-reference","title":"API Reference","text":""},{"location":"#key-classes","title":"Key Classes","text":"<p>The class that the user is mean to rely upon:</p> <ul> <li>Parser: Central class for defining and parsing options.</li> </ul> <p>The other support classes:</p> <ul> <li>Tokenizer: Parses raw command-line options.</li> <li>Option: Base class for all options.</li> <li>ValueOption: Represents options with a single value.</li> <li>ToggleOption: Represents boolean flags.</li> <li>MultiOption: Represents options with predefined values.</li> <li>Separator: Represents an options separator.</li> <li>PositionalOption: Represents options that are not preceded by a flag and     that are in a given order.</li> <li>PositionalList: Represents a list of options that are not preceded by a     flag and that are at the end of the command line.</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Feel free to open issues or submit pull requests to enhance the library.</p>"},{"location":"#license","title":"License","text":"<p>This library is licensed under the MIT License (see <code>LICENSE.md</code>).</p>"}]}